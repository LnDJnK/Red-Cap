<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Red Cap – 6×5 avec cascade</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f1a2c; --cell:#111a2a; --line:#1f2c42;
    --accent:#32d296; --text:#e8f0ff;
    --gold1:#ffd54a; --gold2:#f59e0b;
    --autoOn1:#34d399; --autoOn2:#059669;
    --autoOff1:#cbd5e1; --autoOff2:#94a3b8;
    --danger1:#fb7185; --danger2:#ef4444;
    --ease: cubic-bezier(.22,.61,.36,1);

    /* Réglages visuels */
    --fsredcap-gap: -50px;  /* écart entre fsredcap et le board */
  }

  @font-face{
    font-family: "urban";
    src: url("urban.ttf") format("truetype");
    font-display: swap;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font:500 16px/1.2 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    display:flex; align-items:flex-start; justify-content:center; padding:20px 12px 90px;
    background-color:#050a12;
    overflow-x:hidden;
  }

  /* ====== DOUBLE BACKGROUND avec slide ====== */
  .bg-wrapper{
    position: fixed; inset: 0; z-index: -1; overflow: hidden;
  }
  .bg-wrapper > div{
    position: absolute; inset: 0;
    will-change: transform;
    transition: transform .8s var(--ease);
    background-position: center; background-repeat:no-repeat; background-size:cover;
  }
  .bg-playing{ background-image:url("playing-screen.png"); transform:translateX(0%) }
  .bg-fs{ background-image:url("FS screen.png"); transform:translateX(-100%) }
  body.fs-active .bg-playing{ transform:translateX(100%) }
  body.fs-active .bg-fs{ transform:translateX(0%) }

  .wrap{ width:min(960px, 95vw); position:relative; }
  .panel{
    position: relative;
    background:rgba(15,26,44,.55);
    border:1px solid rgba(19,32,56,.45);
    border-radius:16px;
    padding:14px; box-shadow:0 12px 40px rgba(0,0,0,.35);
    backdrop-filter: blur(2px);
    contain: layout paint;
  }

  .grid{
    display:grid; grid-template-columns:repeat(6,1fr); gap:10px; width:100%;
    overflow:hidden;
    padding:clamp(8px, 1.2vw, 16px);
  }

  .cell{
    aspect-ratio:1/1; position:relative; overflow:visible;
    border:1px solid rgba(31,44,66,.45);
    border-radius:12px;
    background:rgba(17,26,42,.38);
    display:flex; align-items:center; justify-content:center;
    will-change: contents;
  }

  /* ===== Sprites ===== */
  .sprite{
    position: relative; z-index:2; width:90%; height:90%;
    filter:drop-shadow(0 6px 10px rgba(0,0,0,.35));
    will-change: transform, opacity;
    transform: translate3d(0,0,0);
    backface-visibility: hidden;
    transition: transform .2s var(--ease), opacity .2s var(--ease);
    display:flex; align-items:center; justify-content:center;
  }
  .sprite-img{ width:100%; height:100%; object-fit:contain; pointer-events:none; }
  .sprite-img.goc{ transform: none; }
  .sprite-img.fss{ transform: scale(1.15); }

  .case-overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    z-index:3; pointer-events:none; transform-origin:center;
  }
  .case-overlay img{ width:125%; height:125%; object-fit:contain; }

  .case-overlay.lock-rot{ animation: counterSpin .45s linear infinite; }
  @keyframes counterSpin{ from{transform:rotate(0)} to{transform:rotate(-360deg)} }

  .case-overlay.explode{
    animation: counterSpin .45s linear infinite, explodeCloud .6s ease forwards;
  }
  @keyframes explodeCloud{
    0%{ transform:rotate(0) scale(1); opacity:1 }
    40%{ transform:rotate(-160deg) scale(1.4); opacity:.9 }
    70%{ transform:rotate(-280deg) scale(1.8); opacity:.6 }
    100%{ transform:rotate(-360deg) scale(2.2); opacity:0 }
  }

  .sprite.from-panel{ --overshootPx:.04; animation: fallFromPanel .46s var(--ease) both; }
  @keyframes fallFromPanel{
    0%{ transform:translateY(var(--startFromTop,-120vh)); opacity:1 }
    82%{ transform:translateY(calc(var(--overshootPx)*100%)) }
    100%{ transform:translateY(0) }
  }

  .sprite.fall{
    --fallStart:-100%; --startOpacity:1; --overshoot:4%;
    animation: fallVar .18s var(--ease) both;
  }
  @keyframes fallVar{
    0%{ transform:translateY(var(--fallStart)); opacity:var(--startOpacity) }
    75%{ transform:translateY(var(--overshoot)); opacity:1 }
    100%{ transform:translateY(0); opacity:1 }
  }

  .sprite.exit-down{ animation: exitDown .28s var(--ease) forwards }
  @keyframes exitDown{ to{ transform:translateY(130%); opacity:0 } }

  .sprite.pop-win{ animation:popAndFade .46s var(--ease) forwards }
  @keyframes popAndFade{
    0%{ transform:scale(1); opacity:1 }
    50%{ transform:scale(1.15); opacity:1 }
    100%{ transform:scale(.85); opacity:0 }
  }

  .sprite.spin{ animation: spin360 .5s linear forwards }
  .sprite.goc-spin{ animation: spin360 .5s linear forwards }
  .sprite.spin-loop{ animation: spin360 .45s linear infinite; }
  .sprite.spin-burst{ animation: spin360 .45s linear infinite; transform: scale(1.06); }
  @keyframes spin360{ from{transform:rotate(0)} to{transform:rotate(360deg)} }

  .sprite.spin-fade-out{ animation: spin360 .45s linear infinite, fadeOut .55s var(--ease) forwards }
  @keyframes fadeOut{ from{opacity:1} to{opacity:0} }

  .sprite.fade-out-fast{ animation: fadeOut .18s var(--ease) forwards }

  .sprite.tornado-in{ animation: tornadoIn .5s var(--ease) both }
  @keyframes tornadoIn{
    0%{ transform:scale(0) rotate(0); opacity:0 }
    60%{ transform:scale(1.5) rotate(300deg); opacity:1 }
    100%{ transform:scale(1) rotate(360deg); opacity:1 }
  }

  .sprite.spawn-zoom{ animation: spawnZoom .36s var(--ease) both }
  @keyframes spawnZoom{
    0%{ transform:scale(1.12); opacity:0 }
    60%{ transform:scale(0.96); opacity:1 }
    100%{ transform:scale(1); opacity:1 }
  }

  .cell.dimmed::after{
    content:""; position:absolute; inset:0; background:#000; opacity:.38;
    border-radius:12px; pointer-events:none; transition:opacity .18s var(--ease); z-index:6;
  }
  .cell.dimmed.fadeout::after{ opacity:0 }

  .sprite.hit-pulse{ animation: hitPulse .48s var(--ease) infinite alternate }
  @keyframes hitPulse{ from{transform:scale(1)} to{transform:scale(1.08)} }

  .hit-shine{
    position:absolute; inset:0; border-radius:12px;
    background: rgba(255,255,255,.26); mix-blend-mode:screen;
    pointer-events:none; opacity:0; transition:opacity .14s var(--ease); z-index:3;
  }
  .hit-shine.on{ opacity:.85 }

  .tag-bg{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    z-index:0; opacity:.95; pointer-events:none;
  }
  .tag-bg img{ width:95%; height:500%; object-fit:contain; filter:drop-shadow(0 6px 12px rgba(0,0,0,.35)) }
  .tag-bg.tag-pop{ animation: tagPop .38s var(--ease) forwards }
  @keyframes tagPop{
    0%{ transform:scale(.6); opacity:0 }
    70%{ transform:scale(1.06); opacity:.95 }
    100%{ transform:scale(1); opacity:.95 }
  }
  .tag-bg.tag-fade-out{ animation: tagFade .18s ease forwards }
  @keyframes tagFade{ to{ opacity:0; transform:scale(.9) } }

  .wins-layer{ position:absolute; inset:0; pointer-events:none; z-index:10 }
  .win-float{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(0); transform-origin:center;
    font-family:"urban", ui-sans-serif, system-ui; font-weight:900; line-height:1; letter-spacing:.5px;
    color:#ff1f1f; -webkit-text-stroke:3px #fff;
    text-shadow:0 10px 0 rgba(0,0,0,.55), 0 18px 34px rgba(0,0,0,.75), 0 0 2px rgba(0,0,0,.9);
    font-size:clamp(56px, 9vw, 180px); opacity:0;
    animation: winScale .8s var(--ease) forwards, winOut .6s var(--ease) forwards 3s;
  }
  @keyframes winScale{
    0%{ transform:translate(-50%,-50%) scale(0); opacity:0 }
    15%{ opacity:1 }
    70%{ transform:translate(-50%,-50%) scale(1.06) }
    100%{ transform:translate(-50%,-50%) scale(1) }
  }
  @keyframes winOut{ from{opacity:1} to{opacity:0} }

  .controls{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    width:min(960px,95vw);
    display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:10px;
    background:rgba(12,20,36,.75);
    border:1px solid rgba(26,43,69,.5);
    border-radius:14px;
    padding:10px 12px; backdrop-filter: blur(6px); box-shadow:0 10px 30px rgba(0,0,0,.35);
  }
  .badge{background:rgba(12,20,36,.6); border:1px solid rgba(26,43,69,.5); border-radius:10px; padding:8px 10px}

  .btn{
    appearance:none;border:0;border-radius:10px;cursor:pointer;
    padding:10px 16px;background:linear-gradient(180deg,var(--gold1),var(--gold2));
    color:#1a1200;font-weight:800;letter-spacing:.3px;
    box-shadow:0 6px 18px rgba(245,158,11,.35);
    transition:transform .06s ease, filter .15s ease, background .2s ease, color .2s ease;
  }
  .btn:hover{filter:brightness(1.05)}
  .btn:active{transform:translateY(1px)}

  .btn-auto{
    background:linear-gradient(180deg,var(--autoOff1),var(--autoOff2));
    color:#0b1220;
    box-shadow:0 6px 18px rgba(15,23,42,.35);
  }
  .btn-auto.active{ background:linear-gradient(180deg,var(--autoOn1),var(--autoOn2)); color:#04140d }
  .btn-auto.stopping{ background:linear-gradient(180deg,var(--danger1),var(--danger2)); color:white }

  @media (max-width:720px){
    .sprite{ width:86%; height:86% }
    .grid{ padding:10px }
  }

  /* ===== Personnage : glisse et sort complètement ===== */
  .character{
    position: fixed;
    right: clamp(110px, 5vw, 140px); /* (ordre corrigé) */
    bottom: -65px;
    height: min(92vh, 880px);
    max-height: calc(100vh - 110px);
    pointer-events: none;
    z-index: 0;
    transition: right .8s var(--ease), opacity .4s var(--ease);
    will-change: right, opacity;
  }
  body.fs-active .character{
    right: -60vw;   /* part franchement à droite du viewport */
    opacity: 0;
  }

  /* ===== Logo : slide vers la droite (tu as mis 500px) ===== */
  .logo{
    position: absolute; top:-60px; left:-500px; height:500px; pointer-events:none; z-index:2;
    transition: transform .8s var(--ease); will-change: transform;
  }
  body.fs-active .logo{ transform: translateX(calc(100vw - 500px)); }

  /* ===== FS Red Cap : arrive de la GAUCHE et se place à gauche du board ===== */
  .fsredcap {
  position: fixed;
  left: -400px;       /* position de départ hors-écran */
  bottom: -85px;
  height: min(110vh, 1200px); /* <<< ici tu ajustes la taille */
  max-height: calc(100vh - 80px);
  pointer-events: none;
  z-index: 1;
  transition: transform .8s var(--ease);
}
body.fs-active .fsredcap {
  transform: translateX(450px); /* arrive dans la position finale */
}


  /* ====== OVERLAY GROS GAINS ====== */
  .bigwin-overlay{
    position:fixed; inset:0; z-index:9999;
    display:none; align-items:center; justify-content:center; flex-direction:column;
    background: radial-gradient(closest-side, rgba(0,0,0,.55), rgba(0,0,0,.85));
    pointer-events:auto;
  }
  .bigwin-amount{
    font-family:"urban", ui-sans-serif, system-ui;
    font-weight:900; letter-spacing:.5px;
    color:#ffd54a; -webkit-text-stroke:4px #1a1200;
    text-shadow:0 12px 24px rgba(0,0,0,.85), 0 0 6px rgba(255,213,74,.35);
    font-size:clamp(54px,10vw,160px);
    line-height:1; margin:0 0 10px 0;
    transform:scale(.92);
    animation: bigNumberPop .5s var(--ease) both;
  }
  @keyframes bigNumberPop{
    0%{ transform:scale(.7); opacity:0 }
    60%{ transform:scale(1.06); opacity:1 }
    100%{ transform:scale(1) }
  }
  .bigwin-badge{
    width:min(700px, 70vw); height:auto; image-rendering:auto;
    animation: heartBeat 1.05s ease-in-out infinite;
    filter: drop-shadow(0 18px 34px rgba(0,0,0,.65));
    user-select:none; pointer-events:none;
  }
  @keyframes heartBeat{ 0%,100%{transform:scale(1)} 46%{transform:scale(1.08)} }

  /* === Effets FSS === */
  .fss-veil{
    position:absolute; inset:0; border-radius:12px;
    background: rgba(255,255,255,.75); mix-blend-mode:screen;
    opacity:0; pointer-events:none; z-index:5;
    animation: fssFlash .22s ease-in-out 4 both;
  }
  @keyframes fssFlash{ 0%{opacity:0} 50%{opacity:1} 100%{opacity:0} }

  .fss-pop-fx{
    position:absolute; transform:translate(-50%,-50%) scale(1); transform-origin:center;
    z-index:50; width:var(--size,100px); height:var(--size,100px);
    pointer-events:none; display:flex; align-items:center; justify-content:center;
    filter:drop-shadow(0 18px 28px rgba(0,0,0,.45));
  }
  .fss-pop-fx img{ width:100%; height:100%; object-fit:contain }
  .fss-front-pop{ animation: fssFrontBalloon 1.2s cubic-bezier(.22,.61,.36,1) forwards }
  @keyframes fssFrontBalloon{
    0%{ transform:translate(-50%,-50%) scale(1); opacity:1 }
    15%{ transform:translate(-50%,-50%) scale(1.3,.9) }
    30%{ transform:translate(-50%,-50%) scale(.9,1.3) }
    50%{ transform:translate(-50%,-50%) scale(2) }
    70%{ transform:translate(-50%,-50%) scale(4) }
    90%{ transform:translate(-50%,-50%) scale(6); opacity:.9 }
    100%{ transform:translate(-50%,-50%) scale(8); opacity:0 }
  }

  .fs-popup{
    position:fixed; inset:0; background: rgba(0,0,0,.85);
    display:none; align-items:center; justify-content:center; z-index:20000; cursor:pointer;
  }
  .fs-popup-content{
    background:#111a2a; border:4px solid #ffd54a; border-radius:16px;
    padding:30px 28px; text-align:center; color:#fff; font-family:"urban", ui-sans-serif, system-ui;
    max-width:720px; width:min(92vw,720px);
    transform:scale(0); opacity:0; animation: tvOn .6s ease forwards;
    box-shadow:0 22px 70px rgba(0,0,0,.55);
  }
  .fs-popup-content img{ max-width:min(45vw,260px); height:auto; margin-bottom:16px }
  .fs-popup-content h1{
    font-size: clamp(22px, 4.2vw, 44px); margin:6px 0 10px; color:#ffd54a; -webkit-text-stroke:1px #1a1200; letter-spacing:.2px;
  }
  .fs-popup-content p{ font-size: clamp(14px, 2.1vw, 20px); margin:8px 0 }
  .fs-popup-content small{ display:block; margin-top:14px; font-size: clamp(12px,1.8vw,14px); opacity:.85 }

  @keyframes tvOn{
    0%{ transform:scale(0,.02); opacity:0 }
    40%{ transform:scale(1.2,.02); opacity:1 }
    70%{ transform:scale(1.2,1.2) }
    100%{ transform:scale(1,1); opacity:1 }
  }
  @keyframes tvOff{
    0%{ transform:scale(1,1); opacity:1 }
    40%{ transform:scale(1.2,0.1) }
    70%{ transform:scale(0.8,0.02); opacity:.8 }
    100%{ transform:scale(0,0); opacity:0 }
  }
  .fs-popup-content.tv-off{ animation: tvOff .5s ease forwards }
</style>
</head>
<body>

  <!-- Double background -->
  <div class="bg-wrapper">
    <div class="bg-playing"></div>
    <div class="bg-fs"></div>
  </div>

  <div class="wrap">
    <!-- fsredcap : se place à GAUCHE du board quand FS -->
    <img src="fsredcap.png" alt="FS Red Cap" class="fsredcap">

    <div class="panel">
      <div id="grid" class="grid" aria-label="Grille de jeu"></div>
      <div id="wins" class="wins-layer" aria-hidden="true"></div>
      <div id="legend" style="display:none"></div>
    </div>

    <!-- Logo qui glisse à droite -->
    <img src="logo.png" alt="Logo" class="logo">
  </div>

  <!-- Personnage qui sort par la droite -->
  <img src="character.png" alt="Character" class="character">

  <div class="controls">
    <div class="badge">Mise: 1.00 €</div>
    <div class="badge">Gain du spin: <strong id="win">0.00 €</strong></div>
    <div class="badge">Cascades: <strong id="chains">0</strong></div>
    <div class="badge">Solde: <strong id="bank">10 000.00 €</strong></div>
    <button id="autoSpinBtn" class="btn btn-auto">Auto Spin</button>
    <button id="spinBtn" class="btn">Spin</button>
  </div>

  <!-- Overlay gros gains -->
  <div id="bigwin" class="bigwin-overlay" aria-hidden="true">
    <div id="bigwinAmount" class="bigwin-amount">0.00 €</div>
    <img id="bigwinBadge" class="bigwin-badge" src="" alt="" style="display:none">
  </div>

  <!-- POP-UP FREE SPINS -->
  <div id="fsPopup" class="fs-popup" aria-hidden="true">
    <div class="fs-popup-content">
      <img src="fs.png" alt="FS">
      <h1 id="fsTitle">YOU HAVE BEEN AWARDED X FREE SPINS</h1>
      <p>During this slithering bonus, tags are not removed from the boar between spins until you land the Red Cap symbol</p>
      <small>CLICK TO CONTINUE</small>
    </div>
  </div>

<script>
/* ------------------ config ------------------ */
const ROWS=5, COLS=6, MIN_CLUSTER=5;
const BET=1;
const TAG_IMG='tag.png';

/* Vitesses / délais */
const DELAY = { newCol:0.035, newRow:0.08, moveCol:0.0, moveRow:0.0 };
const initialMark = (r,c)=>({ isNew:true, dist:0, fromTop:true });

const FROM_PANEL_MS = 460;
const LOCAL_FALL_MS = 180;
const EXIT_DOWN_MS  = 280;

function computeFallTime({baseMs, colDelay, rowDelay}){
  const maxDelaySec=(COLS-1)*colDelay + (ROWS-1)*rowDelay;
  return baseMs + Math.round(maxDelaySec*1000);
}

/* banque */
let bank=10000;
const $bank=document.getElementById('bank');
function fmt(n){ return n.toLocaleString('fr-FR',{minimumFractionDigits:2,maximumFractionDigits:2}); }
function refreshBank(){ $bank.textContent=fmt(bank)+' €'; }

/* symboles */
const SYM=[
  {id:'TOK',name:'Jeton',src:'token.png'},
  {id:'BAN',name:'Bandana',src:'bandana.png'},
  {id:'CAN',name:'Cannette',src:'can.png'},
  {id:'SHO',name:'Shoes',src:'shoes.png'},
  {id:'BAG',name:'Bag',src:'bag.png'},
  {id:'WAL',name:'Walkman',src:'walkman.png'},
  {id:'SUN',name:'Sunglasses',src:'sunglasses.png'},
  {id:'SK8',name:'Skate',src:'skate.png'},
  {id:'HED',name:'Casque',src:'audio.png'},
  {id:'CAP',name:'Red Cap',src:'red cap.png',alt:'red-cap.png'},
  {id:'GOC',name:'Golden Cap',src:'golden_cap.png'},
  {id:'FSS',name:'Free Spin',src:'fs.png'}
];
const WEIGHTS=[0.4,0.3,0.2,0.15,0.125,0.09,0.06,0.06,0.05,0.04,0.02,0.02];
const IDX_GOC=SYM.findIndex(s=>s.id==='GOC');
const IDX_FSS=SYM.findIndex(s=>s.id==='FSS');

function gridHasGOC(grid){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(grid[r][c]==='GOC') return true;
  }
  return false;
}
function countFSS(grid){
  let n=0;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(grid[r][c]==='FSS') n++;
  }
  return n;
}

function randSymForGrid(grid){
  const w = WEIGHTS.slice();

  let alreadyHasGOC = false;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(grid[r][c] === 'GOC'){ alreadyHasGOC = true; break; }
    }
    if(alreadyHasGOC) break;
  }
  if(alreadyHasGOC) w[IDX_GOC] = 0;

  const fssCount = countFSS(grid);
  if(fssCount >= 4) w[IDX_FSS] = 0;

  const sum = w.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum, acc=0;
  for(let i=0;i<SYM.length;i++){ acc+=w[i]; if(r<=acc) return SYM[i].id; }
  return SYM[SYM.length-1].id;
}

/* tags */
let tagMask=Array.from({length:ROWS},()=>Array(COLS).fill(false));
let justTagged=new Set();

/* barèmes (abrégé) */
const PAY={
  BAG:[{min:26,val:100},{min:13,val:15},{min:11,val:5},{min:9,val:1.5},{min:8,val:0.5},{min:7,val:0.3},{min:6,val:0.2},{min:5,val:0.1}],
  CAN:[{min:26,val:100},{min:13,val:15},{min:11,val:5},{min:9,val:1.5},{min:8,val:0.5},{min:7,val:0.3},{min:6,val:0.2},{min:5,val:0.1}],
  SHO:[{min:26,val:100},{min:13,val:15},{min:11,val:5},{min:9,val:1.5},{min:8,val:0.5},{min:7,val:0.3},{min:6,val:0.2},{min:5,val:0.1}],
  TOK:[{min:26,val:100},{min:13,val:15},{min:11,val:5},{min:9,val:1.5},{min:8,val:0.5},{min:7,val:0.3},{min:6,val:0.2},{min:5,val:0.1}],
  WAL:[{min:26,val:100},{min:13,val:15},{min:11,val:5},{min:9,val:1.5},{min:8,val:0.5},{min:7,val:0.3},{min:6,val:0.2},{min:5,val:0.1}],
  BAN:[{min:26,val:150},{min:13,val:25},{min:11,val:7.5},{min:9,val:2.5},{min:8,val:0.7},{min:7,val:0.5},{min:6,val:0.4},{min:5,val:0.3}],
  SK8:[{min:26,val:150},{min:13,val:25},{min:11,val:7.5},{min:9,val:2.5},{min:8,val:0.7},{min:7,val:0.5},{min:6,val:0.4},{min:5,val:0.3}],
  SUN:[{min:26,val:250},{min:13,val:50},{min:11,val:15},{min:9,val:5},{min:8,val:1.5},{min:7,val:1},{min:6,val:0.7},{min:5,val:0.5}],
  HED:[{min:26,val:250},{min:13,val:50},{min:11,val:15},{min:9,val:5},{min:8,val:1.5},{min:7,val:1},{min:6,val:0.7},{min:5,val:0.5}],
  CAP:[{min:26,val:500},{min:13,val:100},{min:11,val:30},{min:9,val:10},{min:8,val:3},{min:7,val:2},{min:6,val:1.5},{min:5,val:1}]
};
function payFor(id,n){ const t=PAY[id]; if(!t) return 0; let best=0; for(const r of t) if(n>=r.min && r.val>best) best=r.val; return best*BET; }

/* DOM helpers & rendu */
const $grid=document.getElementById('grid');
const $winsLayer=document.getElementById('wins');
const $win=document.getElementById('win');
const $chains=document.getElementById('chains');
const $btn=document.getElementById('spinBtn');

function inBounds(r,c){ return r>=0&&r<ROWS&&c>=0&&c<COLS; }
function makeImg(src,alt){ const img=new Image(); img.src=src; img.alt=''; if(alt){ img.onerror=()=>{img.onerror=null; img.src=alt}; } return img; }
function makeNode(sym){
  const wrap=document.createElement('div');
  wrap.className='sprite';
  const img=makeImg(sym.src,sym.alt);
  img.className='sprite-img'
    + (sym.id==='GOC' ? ' goc' : '')
    + (sym.id==='FSS' ? ' fss' : '');
  wrap.appendChild(img);

  if(sym.id==='GOC'){
    const overlay=document.createElement('div');
    overlay.className='case-overlay';
    overlay.appendChild(makeImg('case.png'));
    wrap.appendChild(overlay);
  }
  return wrap;
}

function swapSpriteAt(cells, r, c, newId){
  const cell = cells[r*COLS + c];
  if(!cell) return;

  const oldSprite = cell.querySelector('.sprite');
  if(oldSprite){ oldSprite.remove(); }

  const wrap = makeNode(SYM.find(s=>s.id===newId));
  wrap.classList.add('tornado-in');
  cell.appendChild(wrap);
}

/* ===== Overlay montant d'un cluster ===== */
function showClusterWin(amount, cells){
  if(!amount || amount<=0) return;
  const panel = document.querySelector('.panel');
  const panelRect = panel.getBoundingClientRect();
  const allCells = [...$grid.children];

  let minR=ROWS, maxR=-1, minC=COLS, maxC=-1;
  for(const [r,c] of cells){
    if(r<minR) minR=r; if(r>maxR) maxR=r;
    if(c<minC) minC=c; if(c>maxC) maxC=c;
  }
  const midR = Math.floor((minR+maxR)/2);
  const midC = Math.floor((minC+maxC)/2);
  const centerCell = allCells[midR*COLS + midC];
  let x = panelRect.width/2, y = panelRect.height/2;

  if(centerCell){
    const rect = centerCell.getBoundingClientRect();
    x = rect.left - panelRect.left + rect.width/2;
    y = rect.top  - panelRect.top  + rect.height/2;
  }

  const el = document.createElement('div');
  el.className = 'win-float';
  el.textContent = `${amount.toFixed(2)}`;
  el.style.left = `${x}px`;
  el.style.top  = `${y}px`;
  $winsLayer.appendChild(el);

  setTimeout(()=>{ el.remove(); }, 3600);
}

/* ---------- Rendu de la grille ---------- */
function renderGrid(grid, marks=new Set(), markMeta=()=>null){
  $grid.innerHTML='';

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const id=grid[r][c];
      const s=SYM.find(x=>x.id===id);
      const cell=document.createElement('div');
      cell.className='cell';
      if(marks.has(`${r},${c}`)) cell.classList.add('hit');

      if(s){
        const node=makeNode(s);
        cell.appendChild(node);

        const meta=markMeta(r,c);
        if(meta){
          const jitterPx = (r*3 + c*5);
          const fromTopVal = `calc(-120vh - ${jitterPx}px)`;

          if(meta.isNew){
            node.classList.add('from-panel');
            node.style.setProperty('--startFromTop', fromTopVal);
            const colDelay = c*DELAY.newCol;
            const rowDelay = r*DELAY.newRow*0.75;
            node.style.animationDelay = (colDelay + rowDelay).toFixed(2)+'s';
          }else if(meta.dist>0){
            node.classList.add('fall');
            node.style.setProperty('--fallStart', `calc(-${meta.dist} * 100%)`);
            node.style.setProperty('--startOpacity', 1);
            node.style.setProperty('--overshoot','4%');
            node.style.animationDelay = '0s';
          }
          node.getBoundingClientRect();
        }
      }

      if(tagMask[r][c]){
        const tag=document.createElement('div');
        tag.className='tag-bg';
        if(justTagged.has(`${r},${c}`)) tag.classList.add('tag-pop');
        tag.appendChild(makeImg(TAG_IMG));
        cell.appendChild(tag);
        justTagged.delete(`${r},${c}`);
      }
      $grid.appendChild(cell);
    }
  }
}

/* ===== Construction de grille ===== */
function makeStartGrid(){
  const grid = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      grid[r][c] = randSymForGrid(grid);
    }
  }
  return grid;
}

function flood(grid,sr,sc,id,seen){
  const st=[[sr,sc]], cells=[];
  while(st.length){
    const [r,c]=st.pop(), key=`${r},${c}`;
    if(seen.has(key)) continue;
    seen.add(key); cells.push([r,c]);
    for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nr=r+dr, nc=c+dc;
      if(inBounds(nr,nc)&&grid[nr][nc]===id&&!seen.has(`${nr},${nc}`)) st.push([nr,nc]);
    }
  }
  return cells;
}
function findAllClusters(grid){
  const seen=new Set(), clusters=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const id=grid[r][c]; if(!id) continue;
    const key=`${r},${c}`; if(seen.has(key)) continue;
    const cells=flood(grid,r,c,id,seen);
    if(cells.length>=MIN_CLUSTER) clusters.push({id,cells});
  }
  return clusters;
}

function applyGravity(grid){
  const moved=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  const isNew=Array.from({length:ROWS},()=>Array(COLS).fill(false));
  for(let c=0;c<COLS;c++){
    let w=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(grid[r][c]!=null){
        moved[w][c]=Math.max(0,w-r);
        grid[w][c]=grid[r][c];
        if(w!==r) grid[r][c]=null;
        w--;
      }
    }
    for(let r=w;r>=0;r--){
      grid[r][c]=randSymForGrid(grid);
      isNew[r][c]=true; moved[r][c]=0;
    }
  }
  return (r,c)=>{ const d=moved[r][c]; if(isNew[r][c]) return {isNew:true, dist:0}; if(d>0) return {isNew:false, dist:d}; return null; };
}

function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

/* Sort la grille actuelle vers le bas avant un nouveau spin */
async function dropOutOldGrid(){
  const cells=[...$grid.children];
  if(!cells.length) return 0;
  const COL_DELAY=40, ROW_DELAY=20;
  let maxDelay=0;

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx=r*COLS+c;
      const cell=cells[idx];
      if(!cell) continue;

      const tag=cell.querySelector('.tag-bg');
      if(tag){ tag.classList.add('tag-fade-out'); }

      const spr=cell.querySelector('.sprite');
      if(!spr) continue;
      const d=c*COL_DELAY + r*ROW_DELAY;
      spr.style.animationDelay = d+'ms';
      spr.classList.add('exit-down');
      if(d>maxDelay) maxDelay=d;
    }
  }
  await wait(EXIT_DOWN_MS + maxDelay + 10);
  return EXIT_DOWN_MS + maxDelay + 10;
}

/* Focus visuel sur HIT */
function applyHitPresentation(hitSet, on){
  const cells=[...$grid.children];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx=r*COLS+c;
      const cell=cells[idx];
      if(!cell) continue;
      const isHit = hitSet.has(`${r},${c}`);

      if(on){
        if(isHit){
          const spr=cell.querySelector('.sprite');
          if(spr) spr.classList.add('hit-pulse');
          if(!cell.querySelector('.hit-shine')){
            const s=document.createElement('div');
            s.className='hit-shine on';
            cell.appendChild(s);
          }else{
            cell.querySelector('.hit-shine').classList.add('on');
          }
        }else{
          cell.classList.add('dimmed');
        }
      }else{
        const spr=cell.querySelector('.sprite');
        spr?.classList.remove('hit-pulse');
        const shine=cell.querySelector('.hit-shine');
        if(shine){ shine.classList.remove('on'); shine.remove(); }
        if(cell.classList.contains('dimmed')){
          cell.classList.add('fadeout');
          cell.classList.remove('dimmed');
          cell.classList.remove('fadeout');
        }
      }
    }
  }
}

function showRemovalWithTag(grid,clusters,placeTags=true){
  const $winsLayer=document.getElementById('wins');
  $winsLayer.innerHTML='';

  const hitSet=new Set();
  clusters.forEach(cl=>cl.cells.forEach(([r,c])=>hitSet.add(`${r},${c}`)));
  renderGrid(grid,hitSet,()=>null);

  const cells=[...$grid.children];
  const POP_MS=460, COL_DELAY=40, ROW_DELAY=22;
  let maxDelay=0;
  let globalStartDelay = Infinity;

  clusters.forEach(cl=>{
    const amount = payFor(cl.id, cl.cells.length);

    let minDelay = Infinity;
    cl.cells.forEach(([r,c])=>{
      const d = c*COL_DELAY + r*ROW_DELAY;
      if(d < minDelay) minDelay = d;
    });
    if(minDelay < globalStartDelay) globalStartDelay = minDelay;

    setTimeout(()=>showClusterWin(amount, cl.cells), Math.max(0, minDelay));

    cl.cells.forEach(([r,c])=>{
      const idx=r*COLS+c;
      const cell=cells[idx];
      const sprite=cell.querySelector('.sprite');
      const delay=c*COL_DELAY + r*ROW_DELAY;
      if(delay>maxDelay) maxDelay=delay;

      if(sprite){
        sprite.style.animationDelay=`${delay}ms`;
        sprite.classList.add('pop-win');
        setTimeout(()=>{
          if(sprite && sprite.parentNode) sprite.parentNode.removeChild(sprite);
          if(placeTags && !cell.querySelector('.tag-bg')){
            const tag=document.createElement('div');
            tag.className='tag-bg tag-pop';
            tag.appendChild(makeImg(TAG_IMG));
            cell.appendChild(tag);
          }
        }, POP_MS+delay);
      }else if(placeTags){
        if(!cell.querySelector('.tag-bg')){
          const tag=document.createElement('div');
          tag.className='tag-bg tag-pop';
          tag.appendChild(makeImg(TAG_IMG));
          cell.appendChild(tag);
        }
      }
      if(placeTags){ tagMask[r][c]=true; justTagged.add(`${r},${c}`); }
    });
  });

  if(globalStartDelay !== Infinity){
    setTimeout(()=>applyHitPresentation(hitSet, true), Math.max(0, globalStartDelay));
  }

  const totalDuration = POP_MS + maxDelay;
  setTimeout(()=>applyHitPresentation(hitSet, false), totalDuration);

  clusters.forEach(cl=>cl.cells.forEach(([r,c])=>grid[r][c]=null));
  return totalDuration;
}

/* ==== GOLDEN CAP mechanic ==== */
let suppressNextTags = false;

async function runGoldenIfPossible(currentGrid){
  if(!anyTags()) return false;

  const gpos = findGoldenPos(currentGrid);
  if(!gpos) return false;
  const [gr,gc]=gpos;

  const cells=[...$grid.children];
  const gocCell=cells[gr*COLS+gc];
  if(!gocCell) return false;

  const gocWrap=gocCell.querySelector('.sprite');
  if(!gocWrap) return false;

  const overlay = gocWrap.querySelector('.case-overlay');

  gocWrap.classList.add('spin-loop');

  if(overlay){
    overlay.classList.add('lock-rot');
    overlay.classList.remove('explode'); void overlay.offsetWidth;
    overlay.classList.add('explode');
    setTimeout(()=>overlay && overlay.remove(), 600);
  }

  const candidates=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(currentGrid[r][c] && currentGrid[r][c]!=='GOC' && currentGrid[r][c]!=='FSS') candidates.push([r,c]);
  }
  if(!candidates.length){
    gocWrap.classList.remove('spin-loop');
    return false;
  }
  const [tr,tc]=candidates[Math.floor(Math.random()*candidates.length)];
  const targetId=currentGrid[tr][tc];
  const targetWrap=cells[tr*COLS+tc]?.querySelector('.sprite');
  if(targetWrap){ targetWrap.classList.add('spin-burst'); }

  await wait(700);

  const replaced=[];
  if(anyTags()){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      if(tagMask[r][c]){
        if(currentGrid[r][c] === 'FSS') continue;
        swapSpriteAt(cells, r, c, targetId);
        replaced.push([r,c]);
      }
    }
  }

  swapSpriteAt(cells, gr, gc, targetId);

  if(targetWrap){ targetWrap.classList.remove('spin-burst'); }

  for(const [r,c] of replaced){ currentGrid[r][c]=targetId; }
  currentGrid[gr][gc]=targetId;

  const createdClusters = findAllClusters(currentGrid)
    .filter(cl => cl.id === targetId && cl.cells.some(([r,c]) =>
      (r===gr && c===gc) || replaced.some(([rr,cc]) => rr===r && cc===c)
    ));

  if (createdClusters.length){
    const preHitSet = new Set();
    createdClusters.forEach(cl => cl.cells.forEach(([r,c]) => preHitSet.add(`${r},${c}`)));
    applyHitPresentation(preHitSet, true);
    setTimeout(() => applyHitPresentation(preHitSet, false), 520);
  }

  await wait(560);
  tagMask = Array.from({length:ROWS},()=>Array(COLS).fill(false));
  justTagged.clear();
  renderGrid(currentGrid,new Set(),()=>null);

  suppressNextTags = true;
  return true;
}

/* ------------------ FSS + POPUP ------------------ */
let fssEffectPlayedThisSpin = false;

function getFSSPositions(grid){
  const pos=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(grid[r][c]==='FSS') pos.push([r,c]);
  }
  return pos;
}

function spawnFSSFrontFXAtCell(cellEl){
  const panel = document.querySelector('.panel');
  const panelRect = panel.getBoundingClientRect();
  const rect = cellEl.getBoundingClientRect();
  const x = rect.left - panelRect.left + rect.width/2;
  const y = rect.top  - panelRect.top  + rect.height/2;

  const fx = document.createElement('div');
  fx.className='fss-pop-fx fss-front-pop';
  fx.style.left = `${x}px`;
  fx.style.top  = `${y}px`;
  fx.style.setProperty('--size', `${rect.width}px`);

  const img = new Image();
  img.src = SYM.find(s=>s.id==='FSS').src;
  img.alt = '';
  fx.appendChild(img);

  document.getElementById('wins').appendChild(fx);
  return fx;
}

async function maybePlayFSSEffect(grid){
  if(fssEffectPlayedThisSpin) return false;
  const positions = getFSSPositions(grid);
  if(positions.length!==3 && positions.length!==4) return false;

  if(isAuto){
    isAuto = false;
    const btn = document.getElementById('autoSpinBtn');
    btn.classList.remove('active','stopping');
    btn.textContent = 'Auto Spin';
  }

  const focusSet = new Set(positions.map(([r,c])=>`${r},${c}`));
  applyHitPresentation(focusSet, true);

  const cells=[...$grid.children];
  const fsAward = (positions.length===3?10:12);

  const promises=[];
  positions.forEach(([r,c])=>{
    const cell=cells[r*COLS+c];
    if(!cell) return;

    const veil=document.createElement('div');
    veil.className='fss-veil';
    cell.appendChild(veil);

    cell.querySelector('.hit-shine')?.remove();

    const p=new Promise(res=>{
      const endFlash = ()=>{
        veil.removeEventListener('animationend', endFlash);
        veil.remove();

        const spr = cell.querySelector('.sprite');
        if(spr){
          spr.classList.remove('hit-pulse');
          spr.remove();
          grid[r][c]=null;

          const fx = spawnFSSFrontFXAtCell(cell);
          fx.addEventListener('animationend', ()=>{ fx.remove(); res(); }, {once:true});
        }else{
          res();
        }
      };
      veil.addEventListener('animationend', endFlash, {once:true});
      setTimeout(endFlash, 1200);
    });
    promises.push(p);
  });

  await Promise.all(promises);

  applyHitPresentation(focusSet, false);

  const markFall=applyGravity(grid);
  renderGrid(grid,new Set(),markFall);
  await wait( Math.max(
    LOCAL_FALL_MS + computeFallTime({baseMs:0,colDelay:DELAY.moveCol,rowDelay:DELAY.moveRow}),
    FROM_PANEL_MS + computeFallTime({baseMs:0,colDelay:DELAY.newCol,rowDelay:DELAY.newRow})
  ) + 20 );

  showFSPopup(fsAward);

  fssEffectPlayedThisSpin = true;
  return true;
}

/* ------- POPUP FS + slides synchronisés ------- */
function showFSPopup(fsCount){
  const popup=document.getElementById('fsPopup');
  const title=document.getElementById('fsTitle');
  title.textContent=`YOU HAVE BEEN AWARDED ${fsCount} FREE SPINS`;
  popup.style.display='flex';

  const content = popup.querySelector('.fs-popup-content');
  popup.onclick=()=>{
    content.classList.add('tv-off');
    content.addEventListener('animationend', ()=>{
      popup.style.display='none';
      content.classList.remove('tv-off');
      /* Active tous les slides via CSS (BG, logo, character OUT, fsredcap IN) */
      document.body.classList.add('fs-active');
    }, {once:true});
  };
}

/* ------------------ flow ------------------ */
let currentGrid = makeStartGrid();
let isSpinning = false;
let isAuto = false;

(async function init(){
  renderGrid(currentGrid,new Set(),initialMark);
  refreshBank();
  await wait(FROM_PANEL_MS + computeFallTime({baseMs:0,colDelay:DELAY.newCol,rowDelay:DELAY.newRow*0.75}));
})();

/* util */
function findGoldenPos(grid){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]==='GOC') return [r,c];
  return null;
}
function anyTags(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(tagMask[r][c]) return true;
  return false;
}

/* ====== Animation de décompte de fin de spin + badges ====== */
let bigWinRunning = false;

function pickBadgeByMultiplier(mult){
  if(mult <= 10) return null;
  if(mult <= 15) return "";
  if(mult <= 25) return "big win.png";
  if(mult <= 50) return "mega win.png";
  if(mult <= 150) return "giga win.png";
  return "epic win.png";
}

function showTotalWinAnimation(total){
  return new Promise(resolve=>{
    const mult = total / BET;
    const badge = pickBadgeByMultiplier(mult);
    if(mult <= 10){ resolve(); return; }

    bigWinRunning = true;
    $btn.disabled = true;
    document.getElementById('autoSpinBtn').disabled = true;

    const overlay = document.getElementById('bigwin');
    const amountEl = document.getElementById('bigwinAmount');
    const badgeEl = document.getElementById('bigwinBadge');
    overlay.style.display = 'flex';
    amountEl.textContent = '0.00 €';

    if(badge === null || badge === ''){
      badgeEl.style.display = 'none';
    }else{
      badgeEl.src = badge;
      badgeEl.style.display = 'block';
    }

    const totalCents = Math.round(total*100);
    let stepCents = 4;
    if(totalCents > 2000) stepCents = 10;
    if(totalCents > 10000) stepCents = 25;
    if(totalCents > 50000) stepCents = 50;

    let currentCents = 0;
    let skipped = false;

    const skipHandler = ()=>{ skipped = true; };
    document.querySelector('.panel').addEventListener('mousedown', skipHandler, { once:true });
    overlay.addEventListener('mousedown', skipHandler, { once:true });

    const close = ()=>{
      overlay.style.display='none';
      bigWinRunning = false;
      $btn.disabled = false;
      document.getElementById('autoSpinBtn').disabled = false;
      resolve();
    };

    const tick = ()=>{
      if(skipped){ currentCents = totalCents; }
      else{
        currentCents += stepCents;
        if(currentCents > totalCents) currentCents = totalCents;
      }
      amountEl.textContent = (currentCents/100).toFixed(2) + ' €';
      if(currentCents < totalCents && !skipped){
        requestAnimationFrame(tick);
      }else{
        amountEl.textContent = total.toFixed(2) + ' $';
        overlay.addEventListener('mousedown', close, { once:true });
        document.querySelector('.panel').addEventListener('mousedown', close, { once:true });
      }
    };
    requestAnimationFrame(tick);
  });
}

/* ========= SPIN ========= */
async function spin(){
  if(isSpinning || bigWinRunning) return;
  if(bank < BET) return;

  isSpinning = true;
  fssEffectPlayedThisSpin = false;
  $btn.disabled=true;
  const $auto=document.getElementById('autoSpinBtn');

  try{
    await dropOutOldGrid();

    document.getElementById('win').textContent='0.00 €';
    document.getElementById('chains').textContent='0';
    document.getElementById('wins').innerHTML='';
    tagMask=Array.from({length:ROWS},()=>Array(COLS).fill(false));
    justTagged.clear();
    suppressNextTags = false;

    bank-=BET; refreshBank();

    currentGrid=makeStartGrid();
    renderGrid(currentGrid,new Set(),initialMark);
    await wait(FROM_PANEL_MS + computeFallTime({baseMs:0,colDelay:DELAY.newCol,rowDelay:DELAY.newRow*0.75}));

    /* FSS juste après la drop initiale */
    await maybePlayFSSEffect(currentGrid);

    let total=0, chain=0;

    while(true){
      while(true){
        const clusters=findAllClusters(currentGrid);
        if(clusters.length===0) break;

        chain++;
        let wave=0; clusters.forEach(cl=>wave+=payFor(cl.id,cl.cells.length));
        total+=wave;

        const placeTags = !suppressNextTags;
        const tagTime=showRemovalWithTag(currentGrid,clusters,placeTags);
        await wait(tagTime+40);
        suppressNextTags = false;

        const markFall=applyGravity(currentGrid);
        document.getElementById('wins').innerHTML='';
        renderGrid(currentGrid,new Set(),markFall);
        await wait( Math.max(
          LOCAL_FALL_MS + computeFallTime({baseMs:0,colDelay:DELAY.moveCol,rowDelay:DELAY.moveRow}),
          FROM_PANEL_MS + computeFallTime({baseMs:0,colDelay:DELAY.newCol,rowDelay:DELAY.newRow})
        ) + 20 );

        await maybePlayFSSEffect(currentGrid);
      }

      const fired = await runGoldenIfPossible(currentGrid);
      if(!fired) break;
    }

    document.getElementById('win').textContent=total.toFixed(2)+' €';
    document.getElementById('chains').textContent=chain;
    bank+=total; refreshBank();

    await showTotalWinAnimation(total);

    if(isAuto && bank < BET){
      isAuto = false;
      $auto.classList.remove('active','stopping');
      $auto.textContent='Auto Spin';
    }
  } finally {
    $btn.disabled=false;
    isSpinning = false;
  }
}

/* --------- Auto Spin ---------- */
const autoSpinBtn = document.getElementById("autoSpinBtn");

autoSpinBtn.addEventListener("click", async () => {
  if(bigWinRunning) return;
  isAuto = !isAuto;
  if(isAuto){
    autoSpinBtn.classList.add("active");
    autoSpinBtn.textContent = "Auto ON";
    (async function autoLoop(){
      while(isAuto){
        if(!isSpinning && !bigWinRunning && bank >= BET){
          await spin();
          await wait(120);
        }else{
          if(bank < BET){
            isAuto = false;
            break;
          }
          await wait(90);
        }
      }
      autoSpinBtn.classList.remove("active","stopping");
      autoSpinBtn.textContent = "Auto Spin";
    })();
  }else{
    autoSpinBtn.classList.add("stopping");
    autoSpinBtn.textContent = "Arrêt…";
  }
});

document.getElementById('spinBtn').addEventListener('click', spin);
</script>
</body>
</html>





